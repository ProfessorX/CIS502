\documentclass[12pt,hyperref=true,mathserif]{beamer}

% Package and Theme
\usepackage{amsmath}
% I suppose listings is no longer needed.
% \usepackage{listings}
\usetheme{AnnArbor}
\graphicspath{{Figure/}{figures/}{figure/}{pictures/}{picture/}{pic/}{pics/}}

% Document Begin
\begin{document}
\title{Revenge of the Nerds}
\author{Yanan Xiao}
\institute[Masdar Institute]{Masdar Institute of Science and
  Technology}
\date[CIS502 Presentation]{Software Engineering Course Presentation}

% Frame Begin
\begin{frame}
\titlepage
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Introduction}


\begin{frame}
% \centering
\begin{center}
``Programming languages have almost caught up with 1958.''
\end{center}
\hfill Paul Graham  
\end{frame}

\begin{frame}
  \frametitle{A Bit of History}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \includegraphics[scale=0.3]{Figure/iMac-500}
    \end{column}
    \begin{column}{0.5\textwidth}
      Question about \emph{computation}.\\[4pt]
      If we had machines that have \textbf{infinite}
      computational power,\\
      what problems would we be able to solve?
    \end{column}
  \end{columns}
  
\end{frame}

\begin{frame}
  Lambda calculus.
  \begin{itemize}
  \item A formal system developed by Alonzo Church.
  \item Essentially a programming language for one of those imaginary
    machines.
  \item Equivalent in power with Turing Machine.
  \end{itemize}
  Lisp.
  \begin{itemize}
  \item Invented by John McCarthy as an implementation of Alonzo's
    lambda calculus, in 1958.
  \item Lisp machine developed by programmers from MIT AI lab, as a
    native hardware implementation.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Functional Programming ABC}
  \begin{columns}
    \begin{column}{0.5\textwidth}
      \includegraphics[scale=0.4]{Figure/Alonzo_Church.jpg}\\
      Alonzo Church
    \end{column}
    \begin{column}{0.5\textwidth}
      \begin{itemize}
      \item A practical implementation of Alonzo Church's ideas.
      \item A set of \textbf{ideas}, not a set of strict
        guidelines.
      \item \textbf{A function is a very basic unit in
          functional programming.}
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}



\section{Functional Programming at a Glimpse}


\begin{frame}
  \frametitle{Functional or Object-Oriented?}
  Objects are little capsules, containing \ldots
  \begin{itemize}
    \item Some internal states.
    \item A collection of method calls.\\[6pt]
  \end{itemize}
  Functional programming tries to \ldots
  \begin{itemize}
    \item Avoid state changes.
    \item Works with data flowing between \textbf{functions}.\\[4pt]
  \end{itemize}
  In this manner, functional programming can be considered the
  opposite of object-oriented programming.
\end{frame}


\begin{frame}
  \frametitle{Theoretical and Practical Advantages}
Functional design may seem like an odd constraint to work
under\footnote{And it is indeed.}. Why should you avoid objects and
side effects? Some sharp benefits are:
\begin{itemize}
  \item Formal provability.\\[4pt]
  \item Modularity.\\[4pt]
  \item Composability.\\[4pt]
  \item Ease of debugging and testing.\\[4pt]
\end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
    \item Formal provability. It's easier to construct a
      \textbf{mathematical proof} that a functional program is correct.\\[4pt]
    \item Modularity. It forces you to break apart your problem into
      \textbf{small pieces}.\\[4pt]
    \item Composability. Over time you will form a personal library of
      utilities. It's because of the modularity benefit.\\[4pt]
    \item Ease of debugging and testing. For debugging: functions are
      generally small and clearly specified. For testing: each
      function is a potential subject fir a unit test.
  \end{itemize}
\end{frame}



\section{More Details}


\begin{frame}[fragile,containsverbatim]
  \frametitle{Concurrency}
A functional program is ready for concurrency without any further
modifications.
\begin{block}{Toy Code in Concurrency}
\begin{verbatim}
String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
\end{verbatim}
\end{block}
As shown above, even if your application is inherently single
threaded, the \textbf{compiler}\footnote{The compiler plays a vital role.} can still optimize
functional programs to run on multiple CPUs.
\end{frame}

% Add some sample code from Erlang when the Internet is back.
\begin{frame}
  \frametitle{Hot Code Deployment}
In a functional program all state is stored on the stack in the
arguments passed to functions. All we'd really have to do is run a
diff between the code in production and the new version, and deploy
the new code.

\end{frame}

\begin{frame}
  \frametitle{Higher Order Functions}

\end{frame}
\section{Dream Language}


\begin{frame}
% \bibliographystyle{plain}
% \bibliography{Reference}
\end{frame}





\end{document}


% Someone like you.
